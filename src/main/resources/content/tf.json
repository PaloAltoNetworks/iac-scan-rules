{
"comment": "!! PLEASE DO NOT EDIT THIS FILE - THIS FILE IS AUTO-GENERATED !!",
"policies": [
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_s3_bucket exists and ($.resource[*].aws_s3_bucket[*].*[*].logging anyNull)",
    "description": "This policy identifies S3 CloudTrail buckets for which access is disabled.S3 Bucket access logging generates access records for each request made to your S3 bucket. An access log record contains information such as the request type, the resources specified in the request worked, and the time and date the request was processed. It is recommended that bucket access logging be enabled on the CloudTrail S3 bucket",
    "id": "41215510-c504-4752-ab38-0a36e49d55f8",
    "enabled": true,
    "resourceType": "s3",
    "policy": "AWS S3 CloudTrail buckets for which access logging is disabled"
  },
  {
    "severity": "high",
    "description": "This policy identifies publicly accessible S3 buckets that store CloudTrail data. These buckets contains sensitive audit data and only authorized users and applications should have access.",
    "rule": "$.resource[*].aws_cloudtrail exists and $.resource[*].aws_cloudtrail[*].*[*].s3_bucket_name equals $.resource[*].aws_s3_bucket_public_access_block[*].*[*].bucket and  ($.resource[*].aws_s3_bucket_public_access_block[*].*[*].block_public_acls isFalse or  $.resource[*].aws_s3_bucket_public_access_block[*].*[*].block_public_policy isFalse)",
    "id": "fc24c16c-f3cc-43b0-aa0e-ba32f5e234d3",
    "enabled": true,
    "resourceType": "AWS_cloudtrail_s3_bucket",
    "policy": "AWS CloudTrail bucket is publicly accessible"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_cloudtrail exists and ($.resource[*].aws_cloudtrail[*].*[*].kms_key_id anyNull or $.resource[*].aws_cloudtrail[*].*[*].kms_key_id anyEmpty)",
    "description": "Checks to ensure that CloudTrail logs are encrypted. AWS CloudTrail is a service that enables governance, compliance, operational & risk auditing of the AWS account. It is a compliance and security best practice to encrypt the CloudTrail data since it may contain sensitive information.",
    "id": "07a06f60-1532-4e2e-b91c-8f972a96f1a9",
    "enabled": true,
    "resourceType": "cloudtrail",
    "policy": "AWS CloudTrail logs are not encrypted using Customer Master Keys (CMKs)"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_kms_key exists and ( $.resource[*].aws_kms_key[*].*[*].enable_key_rotation anyFalse or  $.resource[*].aws_kms_key[*].*[*].enable_key_rotation anyNull)",
    "description": "Checks to ensure that CMKs are rotated periodically. AWS KMS (Key Management Service) allows customers to create master keys to encrypt sensitive data in different services. As a security best practice, it is important to rotate the keys periodically so that if the keys are compromised, the data in the underlying service is still secure with the new keys",
    "id": "497f7e2c-b702-47c7-9a07-f0f6404ac896",
    "enabled": true,
    "resourceType": "kms",
    "policy": "AWS Customer Master Key (CMK) rotation is not enabled"
  },
  {
    "severity": "high",
    "rule": "$.resource[*].aws_default_security_group exists and ($.resource[*].aws_default_security_group[*].*[*].ingress[*].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_default_security_group[*].*[*].ingress[*].ipv6_cidr_blocks[*] contains ::/0 or $.resource[*].aws_default_security_group[*].*[*].egress[*].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_default_security_group[*].*[*].egress[*].ipv6_cidr_blocks[*] contains ::/0)",
    "description": "This policy identifies the default security group which does not restrict all inbound and outbound traffic. A VPC comes with a default security group whose initial configuration deny all inbound traffic from internet and allow all outbound traffic. If you do not specify a security group when you launch an instance, the instance is automatically assigned to this default security group. As a result, the instance may accidentally send outbound traffic.",
    "id": "c8f6a525-e4ba-4499-b015-15153c797143",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS Default Security Group does not restrict all traffic"
  },
  {
    "severity": "high",
    "description": "This policy identifies AWS Security Groups which do allow inbound traffic on SSH port (22) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.",
    "rule": "$.resource[*].aws_security_group exists and ($.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<23 && @.to_port>21 )].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<23 && @.to_port>21 )].ipv6_cidr_blocks[*] contains ::/0)",
    "id": "c2bcdbe7-7c2c-48bc-a0f7-37e1b9766385",
    "enabled": true,
    "resourceType": "Security Group ingress rule",
    "policy": "AWS Security Groups allow internet traffic to SSH port (22)"
  },
  {
    "severity": "medium",
    "description": "The execution IAM Role is required by tasks to pull container images and publish container logs to Amazon CloudWatch on your behalf. This policy generates an alert if a task execution role is not found in your task definition.",
    "rule": " $.resource[*].aws_ecs_task_definition exists and $.resource[*].aws_ecs_task_definition[*].*[*].container_definitions exists and ($.resource[*].aws_ecs_task_definition[*].*[*].execution_role_arn anyNull or $.resource[*].aws_ecs_task_definition[*].*[*].execution_role_arn anyEmpty)",
    "id": "a76c8132-7cc3-40b1-a417-d3a41fc44f89",
    "enabled": true,
    "resourceType": "ecs",
    "policy": "AWS ECS/ Fargate task definition execution IAM Role not found"
  },
  {
    "severity": "low",
    "description": "The user name to use inside the container should not be root. This policy generates an alert if root user is found in your container definition.\n\nThe User parameter maps to User in the Create a container section of the Docker Remote API and the --user option to docker run\n\nNote: This parameter is not supported for Windows containers.",
    "rule": "$.resource[*].aws_ecs_task_definition[*].*[*].container_definitions[?(@.user=='root')] exists",
    "id": "d7cf6d0e-e515-4d0f-b93d-c88932c60172",
    "enabled": true,
    "resourceType": "ECS task definition",
    "policy": "AWS ECS/ Fargate task definition root user found"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_elasticsearch_domain exists and $.resource[*].aws_elasticsearch_domain[*].*[*].vpc_options does not exist",
    "description": "VPC support for Amazon ES is easy to configure, reliable, and offers an extra layer of security. With VPC support, traffic between other services and Amazon ES stays entirely within the AWS network, isolated from the public Internet. You can manage network access using existing VPC security groups, and you can use AWS Identity and Access Management (IAM) policies for additional protection. VPC support for Amazon ES domains is available at no additional charge.",
    "id": "28ee2708-305a-4b23-acf0-535ab45b96ab",
    "enabled": true,
    "resourceType": "elasticsearch",
    "policy": "AWS ElasticSearch cluster not in a VPC"
  },
  {
    "severity": "medium",
    "description": "This policy identifies IAM policies which allow password reuse . AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[*].password_reuse_prevention == 0",
    "id": "c6921472-260e-460a-aa55-77e69e2ee0ba",
    "enabled": true,
    "resourceType": "iam_account_password_policy",
    "policy": "AWS IAM password policy allows password reuse"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[?( @.max_password_age>90 )] is not empty",
    "description": "This policy identifies the IAM policies which does not have password expiration set to 90 days. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "id": "cb4e7ef6-b4b4-45a5-9ae5-194d3a0e12e9",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not expire in 90 days"
  },
  {
    "severity": "medium",
    "description": "Checks to ensure that IAM password policy requires minimum of 14 characters. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[?( @.minimum_password_length<14 )] is not empty",
    "id": "7228106b-f82f-4d2e-a1a0-73fd15f70637",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not have a minimum of 14 characters"
  },
  {
    "severity": "medium",
    "description": "Checks to ensure that IAM password policy requires a lowercase character. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[*].require_lowercase_characters anyFalse",
    "id": "77c2d5a8-071f-48b9-9de0-5917e9b4548d",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not have a lowercase character"
  },
  {
    "severity": "medium",
    "description": "Checks to ensure that IAM password policy requires a number. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[*].require_numbers anyFalse",
    "id": "41fdae49-6fc7-4bc9-80e4-2cbb2262ab7a",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not have a number"
  },
  {
    "severity": "medium",
    "description": "Checks to ensure that IAM password policy requires a symbol. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[*].require_symbols anyFalse",
    "id": "f8013bbf-21b8-4e81-b6ef-7b568407129c",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not have a symbol"
  },
  {
    "severity": "medium",
    "description": "Checks to ensure that IAM password policy requires an uppercase character. AWS IAM (Identity & Access Management) allows customers to secure AWS console access. As a security best practice, customers must have strong password policies in place.",
    "rule": "$.resource[*].aws_iam_account_password_policy[*].*[*].require_uppercase_characters anyFalse",
    "id": "d6dadfcf-a98c-4917-97b5-a5df6a9c493d",
    "enabled": true,
    "resourceType": "iam_account_password",
    "policy": "AWS IAM password policy does not have a uppercase character"
  },
  {
    "severity": "low",
    "description": "This policy identifies IAM policies attached to user.By default, IAM users, groups, and roles have no access to AWS resources. IAM policies are the means by which privileges are granted to users, groups, or roles. It is recommended that IAM policies be applied directly to groups and roles but not users.",
    "rule": "$.resource[*].aws_iam_policy_attachment[*].*[*].users exists and $.resource[*].aws_iam_policy_attachment[*].*[*].users[*] is not empty",
    "id": "1903f355-b68f-4d9c-84dd-c46abe4f8673",
    "enabled": true,
    "resourceType": "iam_policy_attachment",
    "policy": "AWS IAM policy attached to users"
  },
  {
    "severity": "high",
    "rule": "$.resource[*].aws_eks_cluster[*].*[*].version anyStartWith 1.9.",
    "description": "Ensure your EKS Master node version is supported. This policy checks your EKS master node version and generates an alert if the version running is unsupported.",
    "id": "60440266-3d03-41ce-ba8c-d51ccbdb6804",
    "enabled": true,
    "resourceType": "eks",
    "policy": "AWS EKS unsupported Master node version"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_db_instance exists and ( $.resource[*].aws_db_event_subscription !exists or $.resource[*].aws_db_event_subscription[*].*[?(@.source_type=='db-security-group')] anyNull  or not $.resource[*].aws_db_event_subscription[*].*[?(@.source_type=='db-security-group')].enabled anyNull or $.resource[*].aws_db_event_subscription[*].*[?(@.source_type=='db-security-group')].enabled anyTrue )",
    "description": "This policy identifies RDS event subscriptions for which DB security groups event subscription is disabled. You can create an Amazon RDS event notification subscription so that you can be notified when an event occurs for given DB security groups.",
    "id": "b81ceb53-e21a-4456-a35b-ece94323637b",
    "enabled": true,
    "resourceType": "aws_db_event_subscription",
    "policy": "AWS RDS event subscription disabled for DB security groups"
  },
  {
    "severity": "high",
    "rule": "$.resource[*].aws_db_instance exists and ($.resource[*].aws_db_instance[*].*[*].publicly_accessible !exists  or $.resource[*].aws_db_instance[*].*[*].publicly_accessible anyTrue)",
    "description": "This policy identifies AWS RDS snapshots which are accessible to public. Amazon Relational Database Service (Amazon RDS) is a web service that makes it easier to setup and manage databases. If RDS snapshots are inadvertently shared to public, any unauthorized user with AWS console access can gain access to the snapshots and gain access to sensitive data.",
    "id": "054e0760-d0e2-454a-8898-015e9e9fbc1a",
    "enabled": true,
    "resourceType": "rds",
    "policy": "AWS RDS snapshots are accessible to public"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].aws_redshift_parameter_group exists and ($.resource[*].aws_redshift_parameter_group[*].*[*].parameter[?(@.name=='require_ssl')] !exists  or $.resource[*].aws_redshift_parameter_group[*].*[*].parameter[?(@.name=='require_ssl' && @.value=='false' )] exists)",
    "description": "This policy identifies Redshift databases in which data connection to and from is occurring on an insecure channel. SSL connections ensures the security of the data in transit.",
    "id": "2ff03f80-c9f6-4a37-b8b1-1212965e352d",
    "enabled": true,
    "resourceType": "redshift",
    "policy": "AWS Redshift does not have require_ssl configured"
  },
  {
    "severity": "low",
    "description": "This policy identifies S3 CloudTrail buckets for which access is disabled.S3 Bucket access logging generates access records for each request made to your S3 bucket. An access log record contains information such as the request type, the resources specified in the request worked, and the time and date the request was processed. It is recommended that bucket access logging be enabled on the CloudTrail S3 bucket",
    "rule": "$.resource[*].aws_cloudtrail[*].*[*].enable_logging anyFalse",
    "id": "82578260-f754-4e0e-ba6b-a06b9e36ad5b",
    "enabled": true,
    "resourceType": "AWS S3 cloudtrail logging",
    "policy": "AWS S3 CloudTrail buckets for which access logging is disabled"
  },
  {
    "severity": "high",
    "rule": "$.resource[*].aws_s3_bucket exists and ($.resource[*].aws_s3_bucket.*[*].*.acl anyEqual public-read-write or $.resource[*].aws_s3_bucket.*[*].*.acl anyEqual public-read)",
    "description": "This policy identifies S3 buckets which are publicly accessible. Amazon S3 allows customers to store or retrieve any type of content from anywhere in the web. Often, customers have legitimate reasons to expose the S3 bucket to public, for example, to host website content. However, these buckets often contain highly sensitive enterprise data which if left open to public may result in sensitive data leaks.",
    "id": "ded75b65-7ef6-4239-a08f-d4d9a4eb218b",
    "enabled": true,
    "resourceType": "s3",
    "policy": "AWS S3 buckets are accessible to public"
  },
  {
    "severity": "medium",
    "rule": " $.resource[*].aws_s3_bucket exists and ($.resource[*].aws_s3_bucket.*[*].*.versioning[*].enabled does not exist or $.resource[*].aws_s3_bucket.*[*].*.versioning[*].enabled anyFalse)",
    "description": "This policy identifies the S3 buckets which have Object Versioning disabled. S3 Object Versioning is an important capability in protecting your data within a bucket. Once you enable Object Versioning, you cannot remove it; you can suspend Object Versioning at any time on a bucket if you do not wish for it to persist. It is recommended to enable Object Versioning on S3.",
    "id": "1914c65c-2406-4261-88cd-fbeb684a15dc",
    "enabled": true,
    "resourceType": "s3",
    "policy": "AWS S3 Object Versioning is disabled"
  },
  {
    "severity": "high",
    "rule": "$.resource[*].aws_security_group exists and ($.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<3390 && @.to_port>3388 )].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<3390 && @.to_port>3388)].ipv6_cidr_blocks[*] contains ::/0)",
    "description": "This policy identifies the security groups which is exposing RDP port (3389) to the internet. Security Groups do not allow inbound traffic on RDP port (3389) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.",
    "id": "1796efe6-802d-4768-8c17-7491c560b686",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS Security Groups allow internet traffic from internet to RDP port (3389)"
  },
  {
    "severity": "high",
    "description": "This policy identifies AWS Security Groups which do allow inbound traffic on SSH port (22) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.",
    "rule": "$.resource[*].aws_security_group exists and ($.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<23 && @.to_port>21 )].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_security_group[*].*[*].ingress[?( @.protocol == 'tcp' && @.from_port<23 && @.to_port>21 )].ipv6_cidr_blocks[*] contains ::/0)",
    "id": "9745cb18-32f9-4411-a59c-fae4ffa362ce",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS Security Groups allow internet traffic to SSH port (22)"
  },
  {
    "severity": "high",
    "rule": "($.resource[*].aws_security_group exists and ($.resource[*].aws_security_group.*[*].*.ingress[*].protocol equals -1 and ($.resource[*].aws_security_group.*[*].*.ingress[*].cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[*].ipv6_cidr_blocks[*] contains ::/0))) or ($.resource[*].aws_security_group_rule exists and ($.resource[*].aws_security_group_rule.*[*].*.protocol equals -1 and $.resource[*].aws_security_group_rule.*[*].*.type equals ingress and ($.resource[*].aws_security_group_rule.*[*].*.cidr_blocks[*] contains 0.0.0.0/0 or $.resource[*].aws_security_group_rule.*[*].*.ipv6_cidr_blocks[*] contains ::/0)))",
    "description": "This policy identifies AWS Security Groups which do allow inbound traffic on all protocols from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.",
    "id": "eba4d571-4338-4f62-8110-9be6c4b47fd0",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS Security Groups with Inbound rule overly permissive to All Traffic"
  },
  {
    "severity": "medium",
    "description": "Ensure AWS VPC NACL blocks egress traffic from blocked ports",
    "rule": "$.resource[*].aws_network_acl exists and $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].action==allow or $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].action==allow or $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].action==allow or $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '445' && @.to_port == '445')].action==allow or $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].action==allow or $.resource[*].aws_network_acl.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].action==allow",
    "id": "de727ef6-60b0-46b9-a056-29830952c986",
    "enabled": true,
    "resourceType": "AWS NACL egress rules",
    "policy": "AWS VPC NACL allows egress traffic from blocked ports"
  },
  {
    "severity": "medium",
    "description": "Ensure AWS VPC NACL blocks traffic from blocked ports",
    "rule": "$.resource[*].aws_network_acl exists and $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5800' && @.to_port == '5800')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5900' && @.to_port == '5903')].action==allow or  $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '2323' && @.to_port == '2323')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '23' && @.to_port == '23')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '25' && @.to_port == '25')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '110' && @.to_port == '110')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '143' && @.to_port == '143')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '53' && @.to_port == '53')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].action==allow or $.resource[*].aws_network_acl.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].action==allow",
    "id": "1cc0ec13-4079-4e27-b597-9edf83a1cd93",
    "enabled": true,
    "resourceType": "AWS VPC NACL allow traffic",
    "policy": "AWS VPC NACL allows traffic from blocked ports"
  },
  {
    "severity": "medium",
    "description": "This policy identifies the VPCs which have unauthorized peering. The recommended best practice is to disallow VPC peering between two VPCs from different AWS accounts, as this potentially enables unauthorized access to private resources.",
    "rule": "$.resource[*].aws_vpc_peering_connection[*].*[*].peer_vpc_id does not equal $.resource[*].aws_vpc_peering_connection[*].*[*].vpc_id",
    "id": "59356130-d856-470d-a08e-b2a0ba2a4ac7",
    "enabled": true,
    "resourceType": "vpc",
    "policy": "AWS VPC allows unauthorized peering"
  },
  {
    "severity": "medium",
    "description": "Ensure AWS security groups block egress traffic to blocked ports - 21,22,135,137-139,445,69.",
    "rule": "$.resource[*].aws_security_group exists and $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '445' && @.to_port == '445')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'tcp' && @.from_port == '445' && @.to_port == '445')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.egress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].ipv6_cidr_blocks[*] == ::/0 ",
    "id": "2b47072f-0d2b-45a5-aa2d-1db80974176e",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS security group allows egress traffic to blocked ports - 21,22,135,137-139,445,69"
  },
  {
    "severity": "medium",
    "description": "Ensure AWS security groups block ingress ingress traffic from blocked ports - 21,22,135,137-139,445,69.",
    "rule": "$.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '22' && @.to_port == '22')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '21' && @.to_port == '21')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5800' && @.to_port == '5800')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5800' && @.to_port == '5800')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5900' && @.to_port == '5903')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '5900' && @.to_port == '5903')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '2323' && @.to_port == '2323')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '2323' && @.to_port == '2323')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '23' && @.to_port == '23')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '23' && @.to_port == '23')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '25' && @.to_port == '25')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '25' && @.to_port == '25')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '110' && @.to_port == '110')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '110' && @.to_port == '110')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '143' && @.to_port == '143')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'tcp' && @.from_port == '143' && @.to_port == '143')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '53' && @.to_port == '53')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '53' && @.to_port == '53')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '135' && @.to_port == '135')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == '-1' && @.from_port == '137' && @.to_port == '139')].ipv6_cidr_blocks[*] == ::/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].cidr_blocks[*] == 0.0.0.0/0 or $.resource[*].aws_security_group.*[*].*.ingress[?(@.protocol == 'udp' && @.from_port == '69' && @.to_port == '69')].ipv6_cidr_blocks[*] == ::/0",
    "id": "9731fe16-636f-477a-b083-6d90c66d2c0b",
    "enabled": true,
    "resourceType": "security group",
    "policy": "AWS security groups allow ingress traffic from blocked ports"
  },
  {
    "severity": "high",
    "rule": "$.resource.*.azurerm_kubernetes_cluster[*].*[*].role_based_access_control anyNull or $.resource.*.azurerm_kubernetes_cluster[*].*[*].role_based_access_control[*].enabled anyFalse",
    "description": "To provide granular filtering of the actions that users can perform, Kubernetes uses role-based access controls (RBAC). This control mechanism lets you assign users, or groups of users, permission to do things like create or modify resources, or view logs from running application workloads. These permissions can be scoped to a single namespace, or granted across the entire AKS cluster.\n\nThis policy checks your AKS cluster RBAC setting and alerts if disabled.",
    "id": "996f840b-49bf-4340-a117-803e96aa84d0",
    "enabled": true,
    "resourceType": "AKS",
    "policy": "Azure AKS enable role-based access control (RBAC) not enforced"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].azurerm_app_service.*.*.* size > 0 and ($.resource[*].azurerm_app_service[*].*.*.https_only anyNull or $.resource[*].azurerm_app_service[*].*.*.https_only anyFalse)",
    "description": "Azure Web Apps allows sites to run under both HTTP and HTTPS by default. Web apps can be accessed by anyone using non-secure HTTP links by default. Non-secure HTTP requests can be restricted and all HTTP requests redirected to the secure HTTPS port. It is recommended to enforce HTTPS-only traffic.",
    "id": "3555e091-5af1-4ad2-b77e-5b1867d2d496",
    "enabled": true,
    "resourceType": "azurerm_app_service",
    "policy": "Azure App Service Web app doesn't redirect HTTP to HTTPS"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].azurerm_app_service exists and ($.resource[*].azurerm_app_service[*].*.*.client_cert_enabled anyNull or $.resource[*].azurerm_app_service[*].*.*.client_cert_enabled anyFalse)",
    "description": "Client certificates allow for the app to request a certificate for incoming requests. Only clients that have a valid certificate will be able to reach the app.",
    "id": "45d877f2-7215-473c-8684- b7fa129ac491",
    "enabled": true,
    "resourceType": "azurerm_app_service",
    "policy": "Azure App Service Web app doesn't require Client Certs"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].azurerm_app_service.*.*.* size > 0 and ($.resource[*].azurerm_app_service[*].*.*.http2_enabled anyNull or $.resource[*].azurerm_app_service[*].*.*.http2_enabled anyFalse)",
    "description": "HTTP 2.0 has additional performance improvements on the head-of-line blocking problem of old HTTP version, header compression, and prioritization of requests. HTTP 2.0 no longer supports HTTP 1.1's chunked transfer encoding mechanism, as it provides its own, more efficient, mechanisms for data streaming.",
    "id": "514a40c7-a7c4-49d4-a001-b949459ba8c9",
    "enabled": true,
    "resourceType": "azurerm_app_service",
    "policy": "Azure App Service Web app doesn't use HTTP 2.0"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_app_service[*].*[*].identity anyNull",
    "description": "Managed service identity in App Service makes the app more secure by eliminating secrets from the app, such as credentials in the connection strings. When registering with Azure Active Directory in the app service, the app will connect to other Azure services securely without the need of username and passwords.",
    "id": "d18a4314-cb4d-40f7-b21b-47287690771f",
    "enabled": true,
    "resourceType": "App Service",
    "policy": "Azure App Service Web app doesn't have a Managed Service Identity"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_app_service[*].*[*].site_config[?(  @.min_tls_version!='1.2' && @.min_tls_version )] size greater than 0",
    "description": "Check if Azure app service uses latest TLS version",
    "id": "92eeece2-1cbd-4a64-8e15-439a2712e04b",
    "enabled": true,
    "resourceType": "App Service",
    "policy": "Azure App Service Web app doesn't use latest TLS version"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_app_service[*].*[*].auth_settings[*].enabled anyFalse or $.resource.*.azurerm_app_service[*].*[*].auth_settings anyNull ",
    "description": "Azure App Service Authentication is a feature that can prevent anonymous HTTP requests from reaching the API app, or authenticate those that have tokens before they reach the API app. If an anonymous request is received from a browser, App Service will redirect to a logon page. To handle the logon process, a choice from a set of identity providers can be made, or a custom authentication mechanism can be implemented.",
    "id": "d8d4a039-2b04-48c9-80fc-70341eba5c34",
    "enabled": true,
    "resourceType": "App Service",
    "policy": "Azure App Service Web app authentication is off"
  },
  {
    "severity": "high",
    "rule": "($.resource[*].azurerm_network_security_rule exists and ($.resource[*].azurerm_network_security_rule.*[*].*.access contains Allow and $.resource[*].azurerm_network_security_rule.*[*].*.destination_address_prefix contains * and $.resource[*].azurerm_network_security_rule.*[*].*.source_address_prefix contains * and $.resource[*].azurerm_network_security_rule.*[*].*.destination_port_range contains 22 and $.resource[*].azurerm_network_security_rule.*[*].*.direction contains Inbound))",
    "description": "Blocking SSH port 22 will protect users from attacks like Account compromise.",
    "id": "1eb0cd02-789a-4b96-8463-fb5583e40585",
    "enabled": true,
    "resourceType": "Azure Network Security Group",
    "policy": "Azure Network Security Group (NSG) allows SSH traffic from internet on port 22"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_network_security_rule[*].*[?( @.access == 'Allow' && @.direction == 'Inbound' )].destination_port_ranges contains  3389  or $.resource.*.azurerm_network_security_rule[*].*[?( @.access == 'Allow' && @.direction == 'Inbound' )].destination_port_range equals  3389",
    "description": "Blocking RDP port 3389 will protect users from attacks like account compromise, Denial of service and ransomware.",
    "id": "8f9c12f8-1373-4c93-9da1-cccd7f3a33c9",
    "enabled": true,
    "resourceType": "Azure Network Security Group",
    "policy": "Azure Network Security Group (NSG) allows traffic from internet on port 3389"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_network_security_group size greater than 0 and ($.resource.*.azurerm_network_watcher_flow_log size equals 0 or $.resource.*.azurerm_network_watcher_flow_log[*].*[*].enabled anyNull or $.resource.*.azurerm_network_watcher_flow_log[*].*[*].enabled anyFalse or $.resource.*.azurerm_network_watcher_flow_log[*].*[*].retention_policy[*].enabled anyFalse or $.resource.*.azurerm_network_watcher_flow_log[*].*[*].retention_policy[?( @.days<90 )] size greater than 0)",
    "description": "This policy identifies Azure Network Security Groups (NSG) for which flow logs retention period is 90 days or less. To perform this check, enable this action on the Azure Service Principal: 'Microsoft.Network/networkWatchers/queryFlowLogStatus/action'.\n\nNSG flow logs, a feature of the Network Watcher app, enable you to view information about ingress and egress IP traffic through an NSG. The flow logs include information such as:\n- Outbound and inbound flows on a per-rule basis.\n- Network interface to which the flow applies.\n- 5-tuple information about the flow (source/destination IP, source/destination port, protocol).\n- Whether the traffic was allowed or denied.\n\nAs a best practice, enable NSG flow logs and set the log retention period to at least 90 days.",
    "id": "25f2b8ba-1044-470b-95dc-1d096e7b21c2",
    "enabled": true,
    "resourceType": "Azure Network Security Group",
    "policy": "Azure Network Watcher Network Security Group (NSG) flow logs retention is less than 90 days"
  },
  {
    "severity": "medium",
    "rule": " $.resource.*.azurerm_sql_server size greater than 0 and ($.resource.*.azurerm_mssql_server_security_alert_policy size == 0 or  $.resource.*.azurerm_mssql_server_security_alert_policy[*].*[*].state anyEqual \"Disabled\" or $.resource.*.azurerm_mssql_server_security_alert_policy[*].*[*].retention_days anyNull )",
    "description": "Advanced data security (ADS) provides a set of advanced SQL security capabilities, including vulnerability assessment, threat detection, and data discovery and classification.\n\nThis policy identifies Azure SQL servers that do not have ADS enabled. As a best practice, enable ADS on mission-critical SQL servers.",
    "id": "049cb412-96a9-4c93-8561-35857eaf3d78",
    "enabled": true,
    "resourceType": "Azure SQL Server",
    "policy": "Azure SQL Server advanced data security is disabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_sql_server size greater than 0 and ($.resource.*.azurerm_sql_active_directory_administrator size equals 0)",
    "description": "Checks to ensure that SQL servers are configured with Active Directory admin authentication. Azure Active Directory authentication is a mechanism of connecting to Microsoft Azure SQL Database and SQL Data Warehouse by using identities in Azure Active Directory (Azure AD). With Azure AD authentication, you can centrally manage the identities of database users and other Microsoft services in one central location.",
    "id": "48aeadef-967d-46eb-b28c-48c1cca76689",
    "enabled": true,
    "resourceType": "Azure SQL Server",
    "policy": "SQL servers which do not have Azure Active Directory admin configured"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_storage_account size greater than 0 and ($.resource.*.azurerm_storage_account[*].*[*].network_rules anyNull or $.resource.*.azurerm_storage_account[*].*[*].network_rules[*].bypass anyNull or not ( $.resource.*.azurerm_storage_account[*].*[*].network_rules[*].bypass allEqual \"AzureServices\" ))",
    "description": "Some Microsoft services that interact with storage accounts operate from networks that can't be granted access through network rules. To help this type of service work as intended, allow the set of trusted Microsoft services to bypass the network rules. These services will then use strong authentication to access the storage account. If the Allow trusted Microsoft services exception is enabled, the following services: Azure Backup, Azure Site Recovery, Azure DevTest Labs, Azure Event Grid, Azure Event Hubs, Azure Networking, Azure Monitor and Azure SQL Data Warehouse (when registered in the subscription), are granted access to the storage account.",
    "id": "3b26ab70-6d7e-4f8f-808f-d41d3709f02f",
    "enabled": true,
    "resourceType": "Azure Storage Account",
    "policy": "Azure Storage Account 'Trusted Microsoft Services' access not enabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource.*.azurerm_virtual_machine size greater than 0 and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain EndpointSecurity and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain TrendMicroDSA and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain Antimalware and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain EndpointProtection and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain SCWPAgent and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain PortalProtectExtension and $.resource.*.azurerm_virtual_machine_extension[*].*[*].type does not contain FileSecurity",
    "description": "This policy identifies Azure Virtual Machines (VMs) that do not have endpoint protection installed. Installing endpoint protection systems (like Antimalware for Azure) provides for real-time protection capability that helps identify and remove viruses, spyware, and other malicious software. As a best practice, install endpoint protection on all VMs and computers to help identify and remove viruses, spyware, and other malicious software.",
    "id": "8a44e87f-7d8c-4867-977e-8d2a500d205d",
    "enabled": true,
    "resourceType": "Azure Virtual Machine",
    "policy": "Azure Virtual Machine does not have endpoint protection installed"
  },
  {
    "severity": "low",
    "description": "This policy identifies Kubernetes Engine Clusters which have disabled Client Certificate. A client certificate is a base64-encoded public certificate used by clients to authenticate to the cluster endpoint. Enabling Client Certificate will provide more security to authenticate users to the cluster.",
    "rule": "$.resource[*].google_container_cluster[*].*.*.master_auth[*].client_certificate_config[*].issue_client_certificate anyTrue",
    "id": "d07dbdce-2cd8-4b0c-b97e-ceb4d7e98952",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters Client Certificate is set to Disabled"
  },
  {
    "severity": "medium",
    "description": "This policy identifies GCP Kubernetes Engine Clusters which have enabled legacy authorizer. The legacy authorizer in Kubernetes Engine grants broad and statically defined permissions to all cluster users. After legacy authorizer setting is disabled, RBAC can limit permissions for authorized users based on need.",
    "rule": "$.resource[*].google_container_cluster.*.*[*].enable_legacy_abac anyTrue",
    "id": "3a8dde2f-ee02-4d51-bcd1-b119c0207226",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters have Legacy Authorization enabled"
  },
  {
    "severity": "medium",
    "description": "This policy identifies Kubernetes Engine Clusters which have disabled Master authorized networks. Enabling Master authorized networks will let the Kubernetes Engine block untrusted non-GCP source IPs from accessing the Kubernetes master through HTTPS.",
    "rule": "$.resource[*].google_container_cluster[*].*.*.master_authorized_networks_config anyNull",
    "id": "48ed0930-8a52-4426-b196-d0a3969bde11",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters have Master authorized networks disabled"
  },
  {
    "severity": "medium",
    "description": "This policy identifies Kubernetes Engine Clusters which have enabled Basic authentication. Basic authentication allows a user to authenticate to the cluster with a username and password. Disabling Basic authentication will prevent attacks like brute force. Authenticate using client certificate or IAM.",
    "rule": "$.resource.*.google_container_cluster.*.*.*.master_auth exists and not ($.resource.*.google_container_cluster.*.*.*.master_auth.*.password is empty and $.resource.*.google_container_cluster.*.*.*.master_auth.*.username is empty)",
    "id": "b6b3b461-767c-43f5-b608-b84e8c40fa88",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters Basic Authentication is set to Enabled"
  },
  {
    "severity": "low",
    "description": "This policy identifies GCP Kubernetes Engine Clusters which have disabled HTTP load balancing. HTTP/HTTPS load balancing provides global load balancing for HTTP/HTTPS requests destined for your instances. Enabling HTTP/HTTPS load balancers will let the Kubernetes Engine to terminate unauthorized HTTP/HTTPS requests and make better context-aware load balancing decisions.",
    "rule": "$.resource[*].google_container_cluster exists and ($.resource[*].google_container_cluster.*[*].*.addons_config[*].http_load_balancing[*].disabled anyTrue)",
    "id": "afb8ee15-96a4-4f32-83a5-c5f60c49de75",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters have HTTP load balancing disabled"
  },
  {
    "severity": "medium",
    "description": "This policy identifies Kubernetes Engine Clusters which have disabled Network policy. A network policy defines how groups of pods are allowed to communicate with each other and other network endpoints. By enabling network policy in a namespace for a pod, it will reject any connections that are not allowed by the network policy.",
    "rule": "$.resource[*].google_container_cluster exists and  ($.resource[*].google_container_cluster.*[*].*.network_policy anyNull or $.resource[*].google_container_cluster.*[*].*.addons_config[*].network_policy_config anyNull or $.resource[*].google_container_cluster.*[*].*.addons_config[*].network_policy_config[*].disabled anyNull or $.resource[*].google_container_cluster.*[*].*.addons_config[*].network_policy_config[*].disabled anyTrue) ",
    "id": "ca78ea0f-83ec-4401-9c33-300215ebe7b3",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters have Network policy disableds"
  },
  {
    "severity": "low",
    "description": "This policy identifies Kubernetes Engine Clusters which are not configured with the Private cluster. Private cluster makes your master inaccessible from the public internet and nodes do not have public IP addresses, so your workloads run in an environment that is isolated from the internet.",
    "rule": "$.resource[*].google_container_cluster exists and  ($.resource[*].google_container_cluster.*[*].*.private_cluster_config anyNull or $.resource[*].google_container_cluster.*[*].*.private_cluster_config[*].enable_private_nodes anyNull or $.resource[*].google_container_cluster.*[*].*.private_cluster_config[*].enable_private_nodes anyFalse) ",
    "id": "33a04b8d-970b-43c3-b584-c704695178ed",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters not configured with private cluster"
  },
  {
    "severity": "low",
    "description": "This policy identifies Kubernetes Engine Clusters which do not have a container-optimized operating system for node image. Container-Optimized OS is an operating system image for your Compute Engine VMs that is optimized for running Docker containers. By using Container-Optimized OS for node image, you can bring up your Docker containers on Google Cloud Platform quickly, efficiently, and securely. The Container-Optimized OS node image is based on a recent version of the Linux kernel and is optimized to enhance node security. It is also regularly updated with features, security fixes, and patches. The Container-Optimized OS image provides better support, security, and stability than other images.",
    "rule": "$.resource[*].google_container_node_pool exists and  ($.resource[*].google_container_node_pool.*[*].*.node_config anyNull or $.resource[*].google_container_node_pool.*[*].*.node_config[*].image_type anyNull or  not $.resource[*].google_container_node_pool.*[*].*.node_config[*].image_type allStartWith  cos ) ",
    "id": "b80d079e-9db6-440e-a35a-64e53e47e6fc",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters not using Container-Optimized OS for Node image"
  },
  {
    "severity": "medium",
    "description": "This policy identifies service accounts which have admin privileges. Application uses the service account to make requests to the Google API of a service so that the users aren't directly involved. It is recommended not to use admin access for ServiceAccount.",
    "rule": "$.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].member endsWith \".gserviceaccount.com\" or $.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].members any end with \".gserviceaccount.com\" or  $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].member endsWith \".gserviceaccount.com\" or $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].members any end with \".gserviceaccount.com\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].member endsWith \".gserviceaccount.com\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/editor' || @.role=='roles/owner' )].members any end with \".gserviceaccount.com\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/editor' || @.role=='roles/owner' )].member endsWith \".gserviceaccount.com\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/editor' || @.role=='roles/owner' )].members any end with \".gserviceaccount.com\"    or $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/editor' || @.role=='roles/owner' )].member endsWith \".gserviceaccount.com\" or $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/editor' || @.role=='roles/owner' )].members any end with \".gserviceaccount.com\"",
    "id": "acf7e81a-e901-4475-9cdb-d730a1c658bf",
    "enabled": true,
    "resourceType": "IAM",
    "policy": "GCP IAM Service account has admin privileges"
  },
  {
    "severity": "low",
    "description": "Checks to ensure that IAM users don't have service account privileges. Adding any user as service account actor will enable these users to have service account privileges. Adding only authorized corporate IAM users as service account actors will make sure that your information is secure.",
    "rule": "$.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].member startsWith \"user:\"  or $.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].members any start with \"user:\" or  $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].member startsWith \"user:\" or $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].members any start with \"user:\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].member startsWith \"user:\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].members any start with \"user:\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].member startsWith \"user:\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].members any start with \"user:\"  or $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].member startsWith \"user:\"  or  $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/iam.serviceAccountUser' || @.role=='roles/iam.serviceAccountActor' || @.role=='roles/iam.serviceAccountTokenCreator' )].members any start with \"user:\"",
    "id": "9f562f72-2bd6-445b-8d51-ed1212056417",
    "enabled": true,
    "resourceType": "IAM",
    "policy": "GCP IAM user with service account privileges"
  },
  {
    "severity": "low",
    "description": "This policy identifies IAM users who have overly permissive Cloud KMS roles. Built-in/Predefined IAM role Cloud KMS Admin allows the user to create, delete, and manage service accounts. Built-in/Predefined IAM role Cloud KMS CryptoKey Encrypter/Decrypter allows the user to encrypt and decrypt data at rest using the encryption keys. It is recommended to follow the principle of 'Separation of Duties' ensuring that one individual does not have all the necessary permissions to be able to complete a malicious action.",
    "rule": "$.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/cloudkms.admin' )].member startsWith \"user:\"  or $.data[*].google_iam_policy[*].*[*].binding[?( @.role=='roles/cloudkms.admin' )].members any start with \"user:\" or  $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/cloudkms.admin' )].member startsWith \"user:\" or $.resource[*].google_organization_iam_binding[*].binding[?( @.role=='roles/cloudkms.admin' )].members any start with \"user:\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/cloudkms.admin' )].member startsWith \"user:\" or $.resource[*].google_organization_iam_member[*].binding[?( @.role=='roles/cloudkms.admin' )].members any start with \"user:\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/cloudkms.admin')].member startsWith \"user:\"  or $.resource[*].google_project_iam_binding[*].*[?( @.role=='roles/cloudkms.admin')].members any start with \"user:\"  or $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/cloudkms.admin' )].member startsWith \"user:\" or $.resource[*].google_project_iam_member[*].*[?( @.role=='roles/cloudkms.admin' )].members any start with \"user:\"",
    "id": "54839df2-74d6-4642-a12f-807638f89842",
    "enabled": true,
    "resourceType": "IAM",
    "policy": "GCP IAM user have overly permissive Cloud KMS roles"
  },
  {
    "severity": "medium",
    "description": "Application-layer Secrets Encryption provides an additional layer of security for sensitive data, such as Secrets, stored in etcd. Using this functionality, you can use a key, that you manage in Cloud KMS, to encrypt data at the application layer. This protects against attackers who gain access to an offline copy of etcd.\n\nThis policy checks your cluster for the Application-layer Secrets Encryption security feature and alerts if it is not enabled.",
    "rule": "$.resource[*].google_container_cluster exists and ($.resource[*].google_container_cluster[*].*[*].database_encryption anyNull or  $.resource[*].google_container_cluster[*].*[*].database_encryption[*].state any equal DECRYPTED)",
    "id": "7ece6176-027f-4cf7-885e-555d11786c27",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes cluster Application-layer Secrets not encrypteds"
  },
  {
    "severity": "medium",
    "description": "Istio is an open service mesh that provides a uniform way to connect, manage, and secure microservices. It supports managing traffic flows between services, enforcing access policies, and aggregating telemetry data, all without requiring changes to the microservice code.\n\nThis policy checks your cluster for the Istio add-on feature and alerts if it is not enabled.",
    "rule": "$.resource[*].google_container_cluster exists and ($.resource[*].google_container_cluster.*[*].*.addons_config anyNull or $.resource[*].google_container_cluster.*[*].*.addons_config[*].istio_config anyNull or $.resource[*].google_container_cluster.*[*].*.addons_config[*].istio_config[*] anyNull  or  $.resource[*].google_container_cluster.*[*].*.addons_config[*].istio_config[*].disabled anyNull or  $.resource[*].google_container_cluster.*[*].*.addons_config[*].istio_config[*].disabled anyTrue)",
    "id": "6afc115a-d9f9-45e8-9716-6a4204621074",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes cluster istioConfig not enabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_container_cluster[*].*[*].node_config anyNull or $.resource[*].google_container_cluster[*].*[*].node_config[*].service_account anyNull",
    "description": "This policy identifies Kubernetes Engine Cluster Nodes which have default Service account for Project access. By default, Kubernetes Engine nodes are given the Compute Engine default service account. This account has broad access and more permissions than are required to run your Kubernetes Engine cluster. You should create and use a least privileged service account to run your Kubernetes Engine cluster instead of using the Compute Engine default service account. If you are not creating a separate service account for your nodes, you should limit the scopes of the node service account to reduce the possibility of a privilege escalation in an attack.",
    "id": "f125951d-f5c0-4ca6-aab2-d443485e04a1",
    "enabled": true,
    "resourceType": "k8s container cluster service account",
    "policy": "GCP Kubernetes Engine Cluster Nodes have default Service account for Project access"
  },
  {
    "severity": "low",
    "rule": "$.resource[*].google_container_cluster exists and $.resource[*].google_container_cluster[*].*.*.ip_allocation_policy does not exist",
    "description": "This policy identifies Kubernetes Engine Clusters which have disabled Alias IP. Alias IP allows the networking layer to perform anti-spoofing checks to ensure that egress traffic is not sent with arbitrary source IPs. By enabling Alias IPs, Kubernetes Engine clusters can allocate IP addresses from a CIDR block known to Google Cloud Platform. This makes your cluster more scalable and allows your cluster to better interact with other GCP products and entities.",
    "id": "33104909-45f5-4533-8b71-d54716dc7184",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters have Alias IP disabled"
  },
  {
    "severity": "low",
    "rule": "$.resource[*].google_container_cluster.*[*].*.pod_security_policy_config anyNull or $.resource[*].google_container_cluster.*[*].*.pod_security_policy_config.enabled anyFalse",
    "description": "This policy identifies Kubernetes Engine Clusters which have pod security policy disabled. The Pod Security Policy defines a set of conditions that pods must meet to be accepted by the cluster; when a request to create or update a pod does not meet the conditions in the pod security policy, that request is rejected and an error is returned.",
    "id": "b24c52e5-948c-4335-b8e0-c44b86b69538",
    "enabled": true,
    "resourceType": "GCP k8s pod_security",
    "policy": "GCP Kubernetes Engine Clusters have pod security policy disabled"
  },
  {
    "severity": "medium",
    "description": "This policy identifies Kubernetes Engine Clusters which have enabled Kubernetes web UI/Dashboard. Since all the data is being transmitted over HTTP protocol, disabling Kubernetes web UI/Dashboard will protect the data from sniffers on the same network.",
    "rule": "$.resource[*].google_container_cluster exists and $.resource[*].google_container_cluster.*[*].*.addons_config[*].kubernetes_dashboard[*].disabled anyFalse",
    "id": "243d8c63-97cf-434a-b75e-2a84c57fdc37",
    "enabled": true,
    "resourceType": "kubernetes engine",
    "policy": "GCP Kubernetes Engine Clusters web UI/Dashboard is set to Enabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_storage_bucket_access_control[*].*[*].entity contains allUsers",
    "description": "This policy identifies the buckets which are publicly accessible to all authenticated users. Enabling public access to Storage Buckets enables anybody with a web association to access sensitive information that is critical to business. Access over a whole bucket is controlled by IAM. Access to individual objects within the bucket is controlled by its ACLs.",
    "id": "0716cf97-9f82-46ae-8b35-09f2ee41d136",
    "enabled": true,
    "resourceType": "google_storage_bucket_access_control",
    "policy": "GCP Storage buckets are publicly accessible to all authenticated users"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_storage_bucket exists and ($.resource[*].google_storage_bucket.*[*].*.versioning anyNull or $.resource[*].google_storage_bucket.*[*].*.versioning[*].enabled anyNull or $.resource[*].google_storage_bucket.*[*].*.versioning[*].enabled anyFalse)",
    "description": "This policy identifies Storage log buckets which have object versioning disabled. Enabling object versioning on storage log buckets will protect your cloud storage data from being overwritten or accidentally deleted. It is recommended to enable object versioning feature on all storage buckets where sinks are configured.",
    "id": "53a9b6e1-dd93-4110-b443-4658c13134b4",
    "enabled": true,
    "resourceType": "storage",
    "policy": "GCP Storage log buckets have object versioning disabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_service_account_key[*].*[*].service_account_id contains google_service_account or $.resource[*].google_service_account_key[*].*[*].service_account_id any end with iam.gserviceaccount.com",
    "description": "This policy identifies user managed service accounts that use user managed service account keys instead of Google-managed. For user-managed keys, the User has to take ownership of key management activities. Even after owner precaution, keys can be easily leaked by common development malpractices like checking keys into the source code or leaving them in downloads directory or accidentally leaving them on support blogs/channels. So It is recommended to limit the use of User-managed service account keys and instead use Google-managed keys which can not be downloaded.",
    "id": "0173b3d8-91b5-4a10-8105-e92b1f3b5914",
    "enabled": true,
    "resourceType": "service account key",
    "policy": "GCP User managed service accounts have user managed service account keys"
  },
  {
    "severity": "low",
    "rule": "$.resource[*].google_compute_disk exists and $.resource[*].google_compute_disk.*.[*].*.disk_encrypt_key does not exist",
    "description": "This policy identifies VM disks which are not encrypted with Customer-Supplied Encryption Keys (CSEK). If you provide your own encryption keys, Compute Engine uses your key to protect the Google-generated keys used to encrypt and decrypt your data. It is recommended to use VM disks encrypted with CSEK for business-critical VM instances.",
    "id": "3289c0b3-0298-4653-ac41-05c43478b1b0",
    "enabled": true,
    "resourceType": "storage",
    "policy": "GCP VM disks not encrypted with Customer-Supplied Encryption Keys (CSEK)"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_compute_instance_template[*].*.[*].can_ip_forward anyTrue",
    "description": "This policy identifies VM instances have IP forwarding enabled. IP Forwarding could open unintended and undesirable communication paths and allows VM instances to send and receive packets with the non-matching destination or source IPs. To enable source and destination IP match check, disable the IP Forwarding.",
    "id": "c52cef1e-cb56-43dc-8708-fbff0e64b59a",
    "enabled": true,
    "resourceType": "GCP VM instances",
    "policy": "GCP VM instances have IP forwarding enabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_compute_subnetwork[*].*[*].private_ip_google_access anyNull or $.resource[*].google_compute_subnetwork[*].*[*].private_ip_google_access anyFalse",
    "description": "This policy identifies GCP VPC Network subnets have disabled Private Google access. Private Google access enables virtual machine instances on a subnet to reach Google APIs and services using an internal IP address rather than an external IP address. Internal (private) IP addresses are internal to Google Cloud Platform and are not routable or reachable over the Internet. You can use Private Google access to allow VMs without Internet access to reach Google APIs, services, and properties that are accessible over HTTP/HTTPS.",
    "id": "1af7b784-5c6c-43c0-a736-dc5e47cc235a",
    "enabled": true,
    "resourceType": "google compute subnetwork",
    "policy": "GCP VPC Network subnets have Private Google access disabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_project[*].*[*].auto_create_network anyTrue or  $.resource[*].google_project[*].*[*].auto_create_network anyNull",
    "description": "This policy identifies Google Kubernetes Engine (GKE) clusters that are configured to use the default network. Because GKE uses this network when creating routes and firewalls for the cluster, as a best practice define a network configuration that meets your security and networking requirements for ingress and egress traffic, instead of using the default network.",
    "id": "2d372220-3125-48ec-915b-30f0fc5220fb",
    "enabled": true,
    "resourceType": "Google Project",
    "policy": "GCP Kubernetes Engine Clusters using the default network"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_compute_project_metadata_item.[*].[*].[*].key exists and $.resource[*].google_compute_project_metadata_item.[*].[*].[*].key == enable-oslogin and $.resource[*].google_compute_project_metadata_item.[*].[*].[*].value exists and $.resource[*].google_compute_project_metadata_item.[*].[*].[*].value == FALSE",
    "description": "This policy identifies GCP Projects which have OS Login disabled. Enabling OS Login ensures that SSH keys used to connect to instances are mapped with IAM users. Revoking access to IAM user will revoke all the SSH keys associated with that particular user. It facilitates centralized and automated SSH key pair management which is useful in handling cases like a response to compromised SSH key pairs.",
    "id": "6cb4c384-15fc-4b06-8a45-0542144ad8d9",
    "enabled": true,
    "resourceType": "google_compute_project",
    "policy": "GCP Projects have OS Login disabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_sql_database_instance exists and $.resource[*].google_sql_ssl_cert !exists",
    "description": "Checks to verify that the SSL configuration for the SQL instance is valid with an unexpired SSL certificate.\n        Cloud SQL supports connecting to an instance using the Secure Socket Layer (SSL) protocol. If you are not connecting to an instance by using Cloud SQL Proxy, you should use SSL, so that the data you send and receive from Google Cloud SQL is secure.",
    "id": "06362923-51f1-4cc7-95bf-86ecf96b63e8",
    "enabled": true,
    "resourceType": "Google SQL instances",
    "policy": "SQL Instances do not have SSL configured"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_sql_database_instance[*].*[*].settings[*].ip_configuration[*].authorized_networks[*].value anyEqual 0.0.0.0/0 or $.resource[*].google_sql_database_instance[*].*[*].settings[*].ip_configuration[*].authorized_networks[*].value anyEqual ::/0",
    "description": "Checks to verify that the SQL instance should not have any authorization to allow network traffic to the internet.",
    "id": "32865329-308b-4a18-bcf5-fe71423d8770",
    "enabled": true,
    "resourceType": "GCP SQL DB Instance",
    "policy": "SQL Instances with network authorization exposing them to the Internet"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].azurerm_storage_account exists and ($.resource[*].azurerm_storage_account.*[*].*.enable_https_traffic_only anyNull or $.resource[*].azurerm_storage_account.*[*].*.enable_https_traffic_only anyFalse)",
    "description": "The secure transfer option enhances the security of your storage account by only allowing requests to the storage account by a secure connection. For example, when calling REST APIs to access your storage accounts, you must connect using HTTPs. Any requests using HTTP will be rejected when 'secure transfer required' is enabled. When you are using the Azure files service, connection without encryption will fail, including scenarios using SMB 2.1, SMB 3.0 without encryption, and some flavors of the Linux SMB client. Because Azure storage doesn\u2019t support HTTPs for custom domain names, this option is not applied when using a custom domain name.",
    "id": "80f6dc01-4aaa-4712-a7bf-70e103fea4a3",
    "enabled": true,
    "resourceType": "storage",
    "policy": "Storage Accounts without Secure transfer enabled"
  },
  {
    "severity": "medium",
    "rule": "$.resource[*].google_storage_bucket exists and ($.resource[*].google_storage_bucket.*[*].*.logging anyNull or $.resource[*].google_storage_bucket.*[*].*.logging[*].log_bucket anyEmpty)",
    "description": "Checks to verify that the configuration on the Storage Buckets is enabled for access logs and storage logs.",
    "id": "22df2129-f6bf-4a10-9118-42b8d5d922a9",
    "enabled": true,
    "resourceType": "storage",
    "policy": "Storage Bucket does not have Access and Storage Logging enabled"
  }
]
}